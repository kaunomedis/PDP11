### DEC PDP11 (J11) CPU minimal implementation. ###############
# sorry, I do not understand SLEIGH.                          #
# (c)2026, www.vabolis.lt                                     #
#                                        Levas                #
# Freeware & etc. Please leave copyright note                 #
###############################################################


# WARNING! ALL STUFF in {} is untested.

define endian=little;
define alignment=2;

define space ram      type=ram_space      size=2 default; # would like to have 3, but errors...
define space register type=register_space size=2;

# R0–R7 (SP=R6, PC=R7)
define register offset=0x0000 size=2 [ R0 ];
define register offset=0x0002 size=2 [ R1 ];
define register offset=0x0004 size=2 [ R2 ];
define register offset=0x0006 size=2 [ R3 ];
define register offset=0x0008 size=2 [ R4 ];
define register offset=0x000A size=2 [ R5 ];
define register offset=0x000C size=2 [ SP ]; #R6 , stekas mazejantis


define register offset=0x000E size=2 [ PC ]; #R7
define register offset=0x0020 size=2 [ PS ]; # ony one byte. Keep 2 to make SLEIGHT happy

# Flag Register Contents (PS)
#
# b15         - Reserved area
# b14:b12     - Processor interrupt priority level
# b11:b8     - Reserved area
# b7        - (U) Stack pointer select flag
# b6         - (I) Interrupt enable flag
# b5         - (O) Overflow flag
# b4        - (B) Register bank select flag
# b3         - (S) Sign flag
# b2        - (Z) Zero flag
# b1        - (D) Debug flag
# b0        - (C) Carry flag

@define CARRY         "PS[0,1]"
@define DEBUG         "PS[1,1]"
@define ZERO          "PS[2,1]"
@define SIGN          "PS[3,1]"
@define REG_BANK      "PS[4,1]"
@define OVERFLOW    "PS[5,1]"
@define INTERRUPT   "PS[6,1]"
@define STACK_SEL   "PS[7,1]"
@define IPL         "PS[12,3]"

macro flag(register_s, register_d) {
ZERO=( register_s == register_d );
SIGN=( register_s > register_d ); # N
#SIGN= 	sext(register_d);
OVERFLOW=carry(register_s, register_d) || sborrow(register_d, register_s);
CARY=(register_s[15,1]==1) && (register_d[15,1]==1);

}

#
# FLAG MACROS...
#
# Set zero and sign flags from result
macro setResultFlags(result) {
    $(SIGN) = (result s< 0x0);
    $(ZERO) = (result == 0x0);
}
macro push(val) {
    SP = SP - 2;
    ptr:2 = (SP);
    *:2 ptr = val;
}
macro pop(val) {
    ptr:2 = (SP);
    val = *:2 ptr;
    SP = SP + 2;
}

#TOKENS

# main opcode
define token word_1 (16)
	kodas = (6,15)
	metod = (3,5)
	regai =(0,2)
	
	op_h =(8,15)
	rell = (0,7) signed
	baitas = (0,7)
	
	kodas_s = (12,15)
	metod_s=(9,11)
	reg_s=(6,8)
	reg_ss=(6,8)
	metod_d=(3,5)
	reg_d=(0,2)
	reg_dd=(0,2)
	nnn=(0,5)
	fpu=(3,15)
;

attach variables [ reg_s] [ R0 R1 R2 R3 R4 R5 SP PC];
attach variables [ reg_d] [ R0 R1 R2 R3 R4 R5 SP PC];

# one byte, not used here
#define token data8 (8)
#   imm8		= (0,7)
#   rela		= (0,7) signed
#;

# next word with data or first opcode
define token data_word (16)
	imm16 = (0,15)
	rell16	=(0,15) signed
;

# THIS HACK. I do not know how to use two imm16, two words of data (4 bytes)
define token data_double_word (32)
	imm32=(0,31)
	imm32H=(16,31)
	rell32h=(16,31) signed
	imm32L=(0,15)
	rell32l=(0,15) signed
;
# Relative addressing. Note x2 multiplication (adressing is in words)
REL8:	reloc	is rell			[reloc = inst_next + 2 * rell;]	{ export *:2 reloc; } 
# relative values from extra bytes.
REL32H:	reloc 	is rell32h  	[reloc = inst_next + rell32h;]	{ export *:2 reloc; } 
REL32L:	reloc 	is rell32l  	[reloc = inst_next + rell32l;]	{ export *:2 reloc; } 
REL16:	reloc	is rell16   	[reloc = inst_next + rell16;]	{ export *:2 reloc; }
RELN:	reloc	is rell &nnn	[reloc = inst_next-nnn*2;]		{ export *:2 reloc; } 
# NE16:   ne16 	is reg_s [ne16= inst_next;] {export *:2 ne16;}
# offset = offset + inst_next_addr;

# ############# VEIKIANTYS 
:NOP		is imm16=0x0A0	{R0=R0;}
:HALT		is imm16=0		{ PC=(0x28); goto [PC];}
:WAIT		is imm16=1		{ PC=PC-2; goto [PC];}
:CLC		is imm16=0x0A1 {PS[0,1]=0;}
:CLV		is imm16=0x0A2 {PS[5,1]=0;}
:CLZ		is imm16=0x0A4 {PS[2,1]=0;}
:CLN		is imm16=0x0A8 {PS[3,1]=0;}
:CCC		is imm16=0x0AF {PS[0,1]=0; PS[5,1]=0; PS[2,1]=0; PS[3,1]=0; }

:SEC		is imm16=0x0b1 {PS[0,1]=1;}
:SEV		is imm16=0x0b2 {PS[5,1]=1;}
:SEZ		is imm16=0x0b4 {PS[2,1]=1;}
:SEN		is imm16=0x0b8 {PS[3,1]=1;}
:SCC		is imm16=0x0bF {PS[0,1]=1; PS[5,1]=1; PS[2,1]=1; PS[3,1]=1; }
:EMT "'"baitas"'"		is op_h=0x88 & baitas { push(PS); push(PC); PC=(0x18); call [PC];} # NETEISYBE
:TRAP		is op_h=0x89 {push(PS); push(PC); PC=(0x1C); call [PC];} # NETEISYBE
:IOT		is imm16=0x004 {push(PS); push(PC); PC=(0x10); PS=(0x12); call [PC];} # NETEISYBE
:BPT		is imm16=0x003 {push(PS); push(PC); PC=(0x0C); PS=(0x0E); call [PC];} # NETEISYBE
:RTI		is imm16=0x002 {pop(PC); pop(PS); return [PC];} # NETEISYBE
:RTT		is imm16=0x006 {pop(PC); pop(PS); return [PC];} # NETEISYBE
:RESET		is imm16=0x005 {SP=SP;}

:BR   REL8			is op_h=1 & REL8 {goto REL8;}
:BNE  REL8			is op_h=2 & REL8 {if !PS[2,1] goto REL8;} # Z=0
:BEQ  REL8			is op_h=3 & REL8 {if PS[2,1] goto REL8;} # Z=1
:BPL  REL8			is op_h=0x80 & REL8 {if !PS[3,1] goto REL8;} # N=0 sign
:BMI  REL8			is op_h=0x81 & REL8 {if PS[3,1] goto REL8;} # N=1
:BVC  REL8			is op_h=0x84 & REL8 {if !PS[5,1] goto REL8;} # V=0 overflow
:BVS  REL8			is op_h=0x85 & REL8 {if PS[5,1] goto REL8;} # V=1
:BCC  REL8			is op_h=0x86 & REL8 {if !PS[0,1] goto REL8;} # C=0 carry
:BCS  REL8			is op_h=0x87 & REL8 {if PS[0,1] goto REL8;} # C=1
:BGE  REL8			is op_h=4 & REL8 {if !(PS[3,1] ^ PS[5,1]) goto REL8;} # N xor V =0
:BLT  REL8			is op_h=5 & REL8 {if (PS[3,1] ^ PS[5,1]) goto REL8;} # N xor V =1
:BGT  REL8			is op_h=6 & REL8 {if( !(PS[3,1] ^ PS[5,1])|!PS[2,1])goto REL8;} # (N xor V) or Z =0
:BLE  REL8			is op_h=7 & REL8 {if( (PS[3,1] ^ PS[5,1])|PS[2,1])goto REL8;} # (N xor V) or Z =0
:BHI  REL8			is op_h=0x82 & REL8 {if(!PS[0,1] | !PS[2,1])goto REL8;} # C or Z =0
:BLOS REL8			is op_h=0x83 & REL8 {if(PS[0,1] | PS[2,1])goto REL8;} # C or Z =1

# is manualo
# file:///C:/Users/User/Downloads/ghidra_12.0_PUBLIC_20251205/ghidra_12.0_PUBLIC/docs/languages/html/sleigh_constructors.html#sleigh_sections_constructor

####################### VARIANTAI adresacijos #############################################
#export only register names
RRR: reg_s is reg_s { export *:2 reg_s;}
RRD: reg_d is reg_d { export *:2 reg_d;}


# adresacijos metodai (mode)? arba
# 0 - registras Rn ; =R
# 1 - netiesioginis registras @Rn arba (Rn) - viduje registro reiksme; =peek(R)
# 2 - autoinkrementinis (Rn)+ ; =peek(R), R=R+1
# 3 - @(Rn)+
# 4 - -(Rn)
# 5 - @-(Rn)
# 6 - indeksinis X(Rn)
# 7 - @X(Rn)


OPS: reg_s" OK"				is metod_s=0 & reg_s {tmp:2 = *:2 reg_s; export tmp;}
OPS: "("reg_s") OK"			is metod_s=1 & reg_s {tmp:2 = *:2 reg_s; export tmp;}
OPS: "("reg_s")+ OK"		is metod_s=2 & reg_s {tmp:2 = *:2 reg_s; export tmp;}
OPS: "#"imm16" OK"			is metod_s=2 & reg_s=7 ;imm16{tmp:2 = imm16; export tmp;}


OPS: "@("reg_s")+ OK"		is metod_s=3 & reg_s {tmp:2 = *:2 reg_s; export tmp;}
OPS: "@#"imm16" OK"		is metod_s=3 & reg_s=7 ;imm16{tmp:2 = imm16; export tmp;}


OPS: "-("reg_s") OK"		is metod_s=4 & reg_s {tmp:2 = *:2 reg_s; export tmp;}

OPS: "@-("reg_s") OK"		is metod_s=5 & reg_s {tmp:2 = *:2 reg_s; export tmp;}
#OPS: "<5##>"imm16 			is metod_s=5 & metod_d!=5; imm16 {tmp:2 = imm16; export tmp;}
#OPS: "<5##>"imm32L 		is metod_s=5 & metod_d=5; imm32L {tmp:2 = imm32L; export tmp;}

OPS: imm16"("reg_s") OK"	is metod_s=6 & reg_s;imm16{tmp:2 = imm16; export tmp;}
OPS: REL16" OK"			is metod_s=6 & reg_s=7 ;REL16{tmp:2 = REL16; export tmp;}
OPS: imm32L" OK"			is metod_s=6 & metod_d=6 & reg_s=7 ;imm32L{tmp:2 = imm32L; export tmp;}
OPS: imm32L" OK"			is metod_s=6 & metod_d=7 & reg_s=7 ;imm32L{tmp:2 = imm32L; export tmp;}
OPS: imm32L"("reg_s") OK"	is metod_s=6 & metod_d=6 & reg_s ;imm32L{tmp:2 = imm32L; export tmp;}
OPS: imm32L"("reg_s")?OK"	is metod_s=6 & metod_d=7 & reg_s ;imm32L{tmp:2 = imm32L; export tmp;}


OPS: "@"imm16"("reg_s") OK"	is metod_s=7 & reg_s; imm16 {tmp:2 = imm16; export tmp;}
OPS: "@"imm16"("reg_s") OK"	is metod_s=7 & metod_d=6 & reg_s ; imm16{tmp:2 = imm16; export tmp;}
#OPS: "<7c."reg_s">"imm16	is metod_s=7 & metod_d=7 & reg_s ; imm16{tmp:2 = imm16; export tmp;}

OPS: "@"REL16" OK"	is metod_s=7 & reg_s=7 ;REL16{tmp:2 = REL16; export tmp;}
OPS: "<7e.#>"imm16	is metod_s=7 & metod_d=6 & reg_s=7 ;imm16{tmp:2 = imm16; export tmp;}
OPS: "<7f.#"reg_s">"imm32L	is metod_s=7 & metod_d=7 & reg_s ;imm32L{tmp:2 = imm32L; export tmp;}

OPS: "<7g.#>"imm32L	is metod_s=7 & metod_d=7 & reg_s=7 ;imm32L{tmp:2 = imm32L; export tmp;}


# DESTINATION
OPD: reg_d" OK"	is metod_d=0 & reg_d {tmp:2 = *:2 reg_d; export tmp;}
OPD: "("reg_d") OK"	is metod_d=1 & reg_d {tmp:2 = *:2 reg_d; export tmp;}
OPD: "("reg_d")+ OK"	is metod_d=2 & reg_d {tmp:2 = *:2 reg_d; export tmp;}
OPD: "<2#>"imm16	is metod_d=2 & reg_d=7 ;imm16{tmp:2 = imm16; export tmp;}


OPD: "@("reg_d")+ OK"	is metod_d=3 & reg_d {tmp:2 = *:2 reg_d; export tmp;}
OPD: "<3#>"imm16	is metod_d=3 & reg_d=7 ;imm16{tmp:2 = imm16; export tmp;}


OPD: "-("reg_d") OK"	is metod_d=4 & reg_d {tmp:2 = *:2 reg_d; export tmp;}
OPD: "@-("reg_d") OK"	is metod_d=5 & reg_d {tmp:2 = *:2 reg_d; export tmp;}

OPD: imm16"("reg_d") OK"	is metod_d=6 & reg_d;imm16{tmp:2 = imm16; export tmp;}
OPD: REL16" OK"		is metod_d=6 & reg_d=7 ;REL16{tmp:2 = REL16; export tmp;}
# kazkokio reikia: metod_s=2, reg_s=7, metod_d=6, reg_d=1
#OPD: "<6#b>"imm32H		is metod_d=6 & metod_d=2 & reg_s=7 ;imm32H{tmp:2 = imm32H; export tmp;}
#
OPD: imm32H" OK"		is metod_d=6 & metod_s=6 & reg_d=7 ;imm32H{tmp:2 = imm32H; export tmp;}
OPD: "<6#d>"imm32H		is metod_d=6 & metod_s=7 & reg_d=7 ;imm32H{tmp:2 = imm32H; export tmp;}
OPD: imm32H"("reg_d") OK"	is metod_d=6 & metod_s=6 & reg_d ;imm32H{tmp:2 = imm32H; export tmp;}
OPD: imm32H"("reg_d") OK"	is metod_d=6 & metod_s=7 & reg_d ;imm32H{tmp:2 = imm32H; export tmp;}


OPD: "@"imm16"("reg_d") OK"	is metod_d=7 & reg_d; imm16 {tmp:2 = imm16; export tmp;}
OPD: "@"imm32H"("reg_d") OK"	is metod_d=7 & metod_s=6 & reg_d ; imm32H{tmp:2 = imm32H; export tmp;}
#OPD: "<7c."reg_d">"imm16	is metod_d=7 & metod_s=7 & reg_d ; imm16{tmp:2 = imm16; export tmp;}

OPD: "@"REL16" OK"	is metod_d=7 & reg_d=7 ;REL16{tmp:2 = REL16; export tmp;}
OPD: "@"imm32H"?OK"	is metod_d=7 & metod_s=6 & reg_d=7 ;imm32H{tmp:2 = imm32H; export tmp;}
OPD: "<7#c."reg_d">"imm32H	is metod_d=7 & metod_s=7 & reg_d ;imm32H{tmp:2 = imm32H; export tmp;}

OPD: "<7#d>"imm32H	is metod_d=7 & metod_s=7 & reg_d=7 ;imm32H{tmp:2 = imm32H; export tmp;}






# nezinau ar sitie nesutampa su virsutiniais.
OPD2: reg_d			is metod_d=0 & reg_d {tmp:2 = *:2 reg_d; export tmp;}
OPD2: (reg_d)		is metod_d=1 & reg_d {export *[const]:2 reg_d;}

OPD2: (reg_d)+		is metod_d=2 & reg_d {tmp:2 = *:2 reg_d; export tmp;}
OPD2: #imm16		is metod_d=2 & reg_d=7 ; imm16 {tmp:2 = imm16; export tmp;}

OPD2: @(reg_d)+		is metod_d=3 & reg_d {export reg_d;}
OPD2: @#imm16"z"	is metod_d=3 & reg_d=7 ; imm16 {tmp:2 = imm16; export tmp;}

OPD2: -(reg_d)		is metod_d=4 & reg_d {tmp:2 = *:2 reg_d; export tmp;}

OPD2: @-(reg_d)		is metod_d=5 & reg_d {tmp:2 = *:2 reg_d; export tmp;}

OPD2: imm16(reg_d)	is metod_d=6 & reg_dd!=7 &reg_d; imm16 {tmp:2 = imm16; export tmp;}
OPD2: REL8" OK"			is metod_d=6 & reg_dd=7; REL8 {tmp:2 = REL8; export tmp;}

OPD2: @imm16(reg_d)	is metod_d=7 & reg_d; imm16 {tmp:2 = imm16; export tmp;}

OPD2: "<??>"imm16 is metod_d=7 & reg_d=7; imm16 {tmp:2 = imm16; export tmp;}

######### XOR SOB MUL DIV ASH ASHC
:XOR RRR,OPD	is (kodas_s=7 &metod_s=4 & RRR) ...& OPD {OPD=OPD^RRR;}
:SOB RRR,RELN	is (kodas_s=7 &metod_s=7 & RRR & RELN &nnn)
	{RRR=RRR-1;
	if (RRR==0) goto inst_next;
	goto [RELN];
	} # SOB RRR,NNN NNN : R := R – 1; IF (R != 0) THEN PC := PC – 2 * NN

:MUL RRR,OPD	is (kodas_s=7 &metod_s=0 & RRR) ...& OPD {OPD=OPD*RRR;}
:DIV RRR,OPD	is (kodas_s=7 &metod_s=1 & RRR) ...& OPD {OPD=OPD/RRR;}
:ASH RRR,OPD	is (kodas_s=7 &metod_s=2 & RRR) ...& OPD {OPD=RRR;}
:ASHC RRR,OPD2	is (kodas_s=7 &metod_s=3 & RRR) ...& OPD2 {OPD2=RRR;}

##################################################################################

:MOV OPS,OPD 	is (kodas_s=0x1)...& OPD & OPS { OPD = OPS; }
:MOVB OPS,OPD 	is (kodas_s=0x9)...& OPD & OPS { OPD = OPS; }
:CMP OPS,OPD 	is (kodas_s=0x2)...& OPD & OPS { OPD = OPS; }
:CMPB OPS,OPD 	is (kodas_s=0xA)...& OPD & OPS { OPD = OPS; }

:SUB OPS,OPD 	is (kodas_s=0xE)... & OPS & OPD { OPD=OPD-OPS;}
:ADD OPS,OPD 	is (kodas_s=0x6)... & OPS & OPD { OPD=OPD+OPS;}
:BIT OPS,OPD 	is (kodas_s=0x3)... & OPS & OPD { OPD=OPD; }
:BITB OPS,OPD 	is (kodas_s=0xB)... & OPS & OPD { OPD=OPD; }
:BIC OPS,OPD 	is (kodas_s=0x4)... & OPS & OPD { OPD=(~OPS) & OPD; } #bit clear dst=not(src) and (dst)
:BICB OPS,OPD 	is (kodas_s=0xC)... & OPS & OPD { OPD=OPS; }
:BIS OPS,OPD 	is (kodas_s=0x5)... & OPS & OPD { OPD=OPD | OPS; }
:BISB OPS,OPD 	is (kodas_s=0xD)... & OPS & OPD { OPD=OPS; }
:INC OPD2		is (kodas_s=0 & metod_s=5 &reg_s=2)... &OPD2 {OPD2=OPD2+1;}
:INCB OPD2		is (kodas_s=8 & metod_s=5 &reg_s=2)... &OPD2 {PC=PC;}
:CLR OPD2		is (kodas_s=0 & metod_s=5 &reg_s=0)... &OPD2 {OPD2=0;}
:CLRB OPD2		is (kodas_s=8 & metod_s=5 &reg_s=0)... &OPD2 {PC=PC;}

:COM OPD2		is (kodas_s=0 & metod_s=5 &reg_s=1)... &OPD2 {OPD2=~OPD2;}
:COMB OPD2		is (kodas_s=8 & metod_s=5 &reg_s=1)... &OPD2 {PC=PC;}
:DEC OPD2		is (kodas_s=0 & metod_s=5 &reg_s=3)... &OPD2 {OPD2=OPD2-1;}
:DECB OPD2		is (kodas_s=8 & metod_s=5 &reg_s=3)... &OPD2 {PC=PC;}
:NEG OPD2		is (kodas_s=0 & metod_s=5 &reg_s=4)... &OPD2 {OPD2=-OPD2;}
:NEGB OPD2		is (kodas_s=8 & metod_s=5 &reg_s=4)... &OPD2 {PC=PC;}
:ADC OPD2		is (kodas_s=0 & metod_s=5 &reg_s=5)... &OPD2 {if !(PS[0,1]) goto <b>;OPD2=OPD2+1;<b>}
:ADCB OPD2		is (kodas_s=8 & metod_s=5 &reg_s=5)... &OPD2 {OPD2=OPD2;}

:SBC OPD2		is (kodas_s=0 & metod_s=5 &reg_s=6)... &OPD2 {if !(PS[0,1]) goto <b>;OPD2=OPD2-1;<b>}
:SBCB OPD2		is (kodas_s=8 & metod_s=5 &reg_s=6)... &OPD2 {PC=PC;}

:ROR OPD		is (kodas_s=0 & metod_s=6 &reg_s=0)... &OPD {OPD=OPD>>1;}
:RORB OPD		is (kodas_s=8 & metod_s=6 &reg_s=0)... &OPD {OPD=OPD;}
:ROL OPD		is (kodas_s=0 & metod_s=6 &reg_s=1)... &OPD {OPD=OPD<<1;}
:ROLB OPD		is (kodas_s=8 & metod_s=6 &reg_s=1)... &OPD {OPD=OPD;}
:ASR OPD		is (kodas_s=0 & metod_s=6 &reg_s=2)... &OPD {OPD=OPD;}
:ASRB OPD		is (kodas_s=8 & metod_s=6 &reg_s=2)... &OPD {OPD=OPD;}
:ASL OPD		is (kodas_s=0 & metod_s=6 &reg_s=3)... &OPD {OPD=OPD;}
:ASLB OPD		is (kodas_s=8 & metod_s=6 &reg_s=3)... &OPD {OPD=OPD;}
:TST OPD		is (kodas_s=0 & metod_s=5 &reg_s=7)... &OPD {OPD=OPD;}
:TSTB OPD		is (kodas_s=8 & metod_s=5 &reg_s=7)... &OPD {OPD=OPD;}
:SXT OPD2		is (kodas_s=0 & metod_s=6 &reg_s=7)... &OPD2 {tmp=0xFFFF;if (PS[3,1]) goto <b>;tmp=0;<b>OPD2=tmp;}
:SWAB OPD2		is (kodas_s=0 & metod_s=0 &reg_s=3)... &OPD2 {tmp=OPD2>>8; OPD2=OPD2<<8+tmp;}
:MFPS OPD2		is (kodas_s=8 & metod_s=6 &reg_s=7)... &OPD2 {OPD2=PS;}
:MTPS OPD2		is (kodas_s=8 & metod_s=6 &reg_s=4)... &OPD2 {PS=OPD2;}
############################################################################################

# Jumpai (PC registras, R7)
#          543210
# 2 - #X   010 111 = 17
# 3 - @#X  011 111 = 1f
# 6 - X    110 111 = 37
# 7 - @X   111 111 = 3f

# JSR/JMP - need to rewrite
:JMPX REL16   	is (kodas=1 &metod=6 & regai=7) ; REL16 { goto REL16;} #OK
:JMPX "?"OPD		is (kodas=1 &metod=6 & regai!=7)... &OPD  {tmp= OPD; goto [tmp];}
# {tmp=*:2 OPD; goto [tmp];}

:JMP @REL16		is (kodas=1 &metod=7 & regai=7) ; REL16 {goto [REL16];} #JUMP @XXXXX
:JMPI OPD		is (kodas=1 & metod<6)... & OPD {tmp= OPD; goto [tmp];} # JMP R0 ir pan metod:2,3. kiti negalimi

# JSR methods.
JPS: reg_s	is  reg_s {tmp:2 = *:2 reg_s; export tmp;}
I16: imm16	is imm16 {export *:2 imm16;}
# v0=v1; assign v1 to v0.
# *v0=v1; v0 is pointer to space. Store v1 to space
# *[space]v0=v1;
# *:4 v0 = v1;
# *[space]:4 v0=v1;
#
# galimi tik sitie
# goto v0; goto to address of v0
# goto [v0]; goto to as offset of current space
# call v0;
# call [v0];
# return [v0];



:JSR JPS,#I16	is (kodas_s=0 & metod_s=4 & reg_s<7 & reg_d=7 & metod_d=2)& JPS ;I16 {tmp=JPS+I16; call [tmp];}
:JSR JPS,@#I16	is (kodas_s=0 & metod_s=4 & reg_s<7 & reg_d=7 & metod_d=3)& JPS ;I16 {tmp=I16+JPS; call [*:2 tmp];}

:JSR JPS,REL16	is (kodas_s=0 & metod_s=4 & reg_s<7 & reg_d=7 & metod_d=6)& JPS ;REL16 {tmp=JPS+REL16; call [*:2 tmp];}
:JSR JPS,@REL16	is (kodas_s=0 & metod_s=4 & reg_s<7 & reg_d=7 & metod_d=7)& JPS ;REL16 {tmp=JPS+REL16; call [*:2 tmp];}

:JSR "PC?",OPD2	is (kodas=0x27 & reg_d!=7)... & OPD2 {call OPD2;}

:"ILLEGAL CALL 0>"REL16	is (kodas=0x27 & metod_d=0 & reg_d=7) ; REL16 { *SP=PC; SP=SP-1; call REL16; }
:"ILLEGAL CALL 1>"REL16	is (kodas=0x27 & metod_d=1 & reg_d=7) ; REL16 { *SP=PC; SP=SP-1; call REL16; }
:CALL #I16				is (kodas=0x27 & metod_d=2 & reg_d=7) ; I16 {call [I16];}
:CALL @#I16				is (kodas=0x27 & metod_d=3 & reg_d=7) ; I16 {call I16; }
:"ILLEGAL CALL 4>"REL16	is (kodas=0x27 & metod_d=4 & reg_d=7) ; REL16 { *SP=PC; SP=SP-1; call REL16; }
:"ILLEGAL CALL 5>"REL16	is (kodas=0x27 & metod_d=5 & reg_d=7) ; REL16 { *SP=PC; SP=SP-1; call REL16; }
:CALL REL16				is (kodas=0x27 & metod_d=6 & reg_d=7) ; REL16 { *SP=PC; SP=SP-1; call REL16; }
:CALL "@"REL16			is (kodas=0x27 & metod_d=7 & reg_d=7) ; REL16 { *SP=PC; SP=SP-1; call REL16; }

###### RETURN
:RETURN		is imm16=0x87 {pop(PC); pop(PS); return [PC];}
:RTS RRD	is kodas=2 & metod=0 & regai<7 &RRD {pop(PC); pop(RRD); return [PC];}


:MARK nnn is kodas=0x34 &nnn {SP=PC+2*nnn;PC=R5;pop(R5);} # SP := PC + 2 * NN; PC := R5; R5 := (SP)+
 


######## FPU FPU FPU #########################

FRD: reg_d is reg_d			{ export *:1 reg_d; }
:FADD FRD	is fpu=0b0111101000000 & FRD {PC=PC;}
:FSUB FRD	is fpu=0b0111101000001 & FRD {PC=PC;}
:FMUL FRD	is fpu=0b0111101000010 & FRD {PC=PC;}
:FDIV FRD	is fpu=0b0111101000011 & FRD {PC=PC;}

######## HALT MODE ############################

#:START ($RUN$) = o10-o13
#:STEP ($STEP$) =o14-o17
#:RSEL ($MFSL$) =o20
#:MFUS ($MFPM$) = o21
#:RCPC ($MFPC$) = o22-o23
#:RCPS ($MFPS$) = o24-o27
#:MTUS ($MTPM$) = o31
#:WCPC ($MTPC$) = o32-o33
#:WCPS ($MTPS$) = o34-o37
#:???? = o30


# programinis dugnas. (c)2026 http://www.vabolis.lt