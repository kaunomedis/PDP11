### DEC PDP11 (J11) CPU minimal implementation. ###############
# sorry, I do not understand SLEIGH.                          #
# (c)2026, www.vabolis.lt                                     #
#                                        Levas                #
# Freeware & etc. Please leave copyright note                 #
###############################################################

# WARNING! ALL STUFF in {} is untested.

define endian=little;
define alignment=2;

define space ram      type=ram_space      size=2 default; # would like to have 3, but errors...
define space register type=register_space size=1;

# R0–R7 (SP=R6, PC=R7)
define register offset=0x0000 size=2 [ R0 ];
define register offset=0x0002 size=2 [ R1 ];
define register offset=0x0004 size=2 [ R2 ];
define register offset=0x0006 size=2 [ R3 ];
define register offset=0x0008 size=2 [ R4 ];
define register offset=0x000A size=2 [ R5 ];
define register offset=0x000C size=2 [ SP ]; #R6 , stekas mazejantis


define register offset=0x000E size=2 [ PC ]; #R7
define register offset=0x0020 size=2 [ FLG ]; # ony one byte. Keep 2 to make SLEIGHT happy

# Flag Register Contents (FLG)
#
# b15         - Reserved area
# b14:b12     - Processor interrupt priority level
# b11:b8     - Reserved area
# b7        - (U) Stack pointer select flag
# b6         - (I) Interrupt enable flag
# b5         - (O) Overflow flag
# b4        - (B) Register bank select flag
# b3         - (S) Sign flag
# b2        - (Z) Zero flag
# b1        - (D) Debug flag
# b0        - (C) Carry flag

@define CARRY         "FLG[0,1]"
@define DEBUG         "FLG[1,1]"
@define ZERO          "FLG[2,1]"
@define SIGN          "FLG[3,1]"
@define REG_BANK      "FLG[4,1]"
@define OVERFLOW    "FLG[5,1]"
@define INTERRUPT   "FLG[6,1]"
@define STACK_SEL   "FLG[7,1]"
@define IPL         "FLG[12,3]"


#
# FLAG MACROS...
#
# Set zero and sign flags from result
macro setResultFlags(result) {
    $(SIGN) = (result s< 0x0);
    $(ZERO) = (result == 0x0);
}
macro push(val) {
    SP = SP - 2;
    ptr:3 = zext(SP);
    *:2 ptr = val;
}
macro pop(val) {
    ptr:3 = zext(SP);
    val = *:2 ptr;
    SP = SP + 2;
}

#TOKENS

# main opcode
define token word_1 (16)
	kodas = (6,15)
	metod = (3,5)
	regai =(0,2)
	
	op_h =(8,15)
	rel = (0,7) signed
	baitas = (0,7)
	
	kodas_s = (12,15)
	metod_s=(9,11)
	reg_s=(6,8)
	reg_ss=(6,8)
	metod_d=(3,5)
	reg_d=(0,2)
	reg_dd=(0,2)
	nnn=(0,5)
	fpu=(3,15)
;

attach variables [ reg_s] [ R0 R1 R2 R3 R4 R5 SP PC];
attach variables [ reg_d] [ R0 R1 R2 R3 R4 R5 SP PC];

# one byte, not used here
define token data8 (8)
   imm8		= (0,7)
   rela		= (0,7) signed
;

# next word with data or first opcode
define token data_word (16)
	imm16 = (0,15)
	rell	=(0,15) signed
;



# THIS HACK. I do not know how to use two imm16, two words of data (4 bytes)
define token data_double_word (32)
	imm32=(0,31)
	imm32H=(16,31)
	imm32L=(0,15)
;
# Relative addressing. Note x2 multiplication (adressing is in words)
REL: reloc		is rel	[ reloc = inst_next + 2 * rel; ] { export *:2 reloc; } 

# ############# VEIKIANTYS 
:NOP		is imm16=0x0A0 {	R0=R0;}
:HALT		is imm16=0 { PC=123;}
:WAIT		is imm16=1 { PC=PC-2;}
:CLC		is imm16=0x0A1 {FLG[0,1]=0;}
:CLV		is imm16=0x0A2 {FLG[5,1]=0;}
:CLZ		is imm16=0x0A4 {FLG[2,1]=0;}
:CLN		is imm16=0x0A8 {FLG[3,1]=0;}
:CCC		is imm16=0x0AF {FLG[0,1]=0; FLG[5,1]=0; FLG[2,1]=0; FLG[3,1]=0; }

:SEC		is imm16=0x0b1 {FLG[0,1]=1;}
:SEV		is imm16=0x0b2 {FLG[5,1]=1;}
:SEZ		is imm16=0x0b4 {FLG[2,1]=1;}
:SEN		is imm16=0x0b8 {FLG[3,1]=1;}
:SCC		is imm16=0x0bF {FLG[0,1]=1; FLG[5,1]=1; FLG[2,1]=1; FLG[3,1]=1; }
:EMT "'"baitas"'"		is op_h=0x88 & baitas { PC=(18);} # NETEISYBE
:TRAP		is op_h=0x89 { PC=(36);} # NETEISYBE
:IOT		is imm16=0x004 {PC=(20);} # NETEISYBE
:BPT		is imm16=0x003 {PC=(14);} # NETEISYBE
:RTI		is imm16=0x002 {SP=SP+2;} # NETEISYBE
:RTT		is imm16=0x006 {SP=SP+2;} # NETEISYBE
:RESET		is imm16=0x005 {SP=SP;}

:BR   REL			is op_h=1 & REL {goto REL;}
:BNE  REL			is op_h=2 & REL {if !FLG[2,1] goto REL;} # Z=0
:BEQ  REL			is op_h=3 & REL {if FLG[2,1] goto REL;} # Z=1
:BPL  REL			is op_h=0x80 & REL {if !FLG[3,1] goto REL;} # N=0 sign
:BMI  REL			is op_h=0x81 & REL {if FLG[3,1] goto REL;} # N=1
:BVC  REL			is op_h=0x84 & REL {if !FLG[5,1] goto REL;} # V=0 overflow
:BVS  REL			is op_h=0x85 & REL {if FLG[5,1] goto REL;} # V=1
:BCC  REL			is op_h=0x86 & REL {if !FLG[0,1] goto REL;} # C=0 carry
:BCS  REL			is op_h=0x87 & REL {if FLG[0,1] goto REL;} # C=1
:BGE  REL			is op_h=4 & REL {if !(FLG[3,1] ^ FLG[5,1]) goto REL;} # N xor V =0
:BLT  REL			is op_h=5 & REL {if (FLG[3,1] ^ FLG[5,1]) goto REL;} # N xor V =1
:BGT  REL			is op_h=6 & REL {goto REL;} # (N xor V) or Z =0
:BLE  REL			is op_h=7 & REL {goto REL;} # (N xor V) or Z =0
:BHI  REL			is op_h=0x82 & REL {goto REL;} # C or Z =0
:BLOS REL			is op_h=0x83 & REL {goto REL;} # C or Z =1

# is manualo
# file:///C:/Users/User/Downloads/ghidra_12.0_PUBLIC_20251205/ghidra_12.0_PUBLIC/docs/languages/html/sleigh_constructors.html#sleigh_sections_constructor

####################### VARIANTAI adresacijos #############################################
#export only register names
RRR: reg_s is reg_s { export *:2 reg_s;}
RRD: reg_d is reg_d { export *:2 reg_d;}


# adresacijos metodai (mode)? arba
# 0 - registras Rn
# 1 - netiesioginis registras @Rn arba (Rn) - viduje registro reiksme
# 2 - autoinkrementinis (Rn)+
# 3 - @(Rn)+
# 4 - -(Rn)
# 5 - @-(Rn)
# 6 - indeksinis X(Rn)
# 7 - @X(Rn)

# OPerator Source [OPS]. All possible methods.
OPS: reg_s			is metod_s=0 & reg_s {tmp:2 = *:2 reg_s; export tmp;}
OPS: (reg_s)		is metod_s=1 & reg_s {export *[const]:2 reg_s;}

OPS: (reg_s)+		is metod_s=2 & reg_s {tmp:2 = *:2 reg_s; export tmp;}
OPS: #imm16			is metod_s=2 & reg_ss=7 & metod_d!=2; imm16 {tmp:2 = imm16; export tmp;}
OPS: #imm32L		is metod_s=2 & metod_d=2 & reg_s;imm32L {tmp:2 = imm32L; export tmp;}

OPS: @(reg_s)+		is metod_s=3 & reg_s {export reg_s;}
OPS: @#imm16"z"		is metod_s=3 & reg_s=7 ; imm16 {tmp:2 = imm16; export tmp;}
OPS: @#imm32L"zz"	is metod_s=3 & reg_s=7 & reg_d=7 ;imm32L {tmp:2 = imm32L; export tmp;}


OPS: -(reg_s)		is metod_s=4 & reg_s {tmp:2 = *:2 reg_s; export tmp;}
OPS: @-(reg_s)		is metod_s=5 & reg_s {tmp:2 = *:2 reg_s; export tmp;}

OPS: imm16(reg_s)	is metod_s=6 & reg_s; imm16 {tmp:2 = imm16; export tmp;}
OPS: imm32L(reg_s)	is metod_s=6 & metod_d=7 & reg_s; imm32L {tmp:2 = imm32L; export tmp;}
OPS: imm32L(reg_s)	is metod_s=6 & metod_d=6 & reg_s; imm32L {tmp:2 = imm32L; export tmp;}

OPS: @imm16(reg_s)	is metod_s=7 & reg_s; imm16 {tmp:2 = imm16; export tmp;}
OPS: @imm32L(reg_s)	is metod_s=7 & metod_d=7 & reg_s; imm32L {tmp:2 = imm32L; export tmp;}
OPS: @imm32L(reg_s)	is metod_s=7 & metod_d=6 & reg_s; imm32L {tmp:2 = imm32L; export tmp;}


# OPerator Destination [OPD]. All possible methods.
OPD: reg_d			is metod_d=0 & reg_d {tmp:2 = *:2 reg_d; export tmp;}
OPD: (reg_d)		is metod_d=1 & reg_d {export *[const]:2 reg_d;}

OPD: (reg_d)+		is metod_d=2 & reg_d {tmp:2 = *:2 reg_d; export tmp;}
OPD: #imm16			is metod_d=2 & reg_dd=7 &metod_s!=2; imm16 {tmp:2 = imm16; export tmp;}
OPD: #imm32H		is metod_d=2 & metod_s=2 &reg_d;imm32H {tmp:2 = imm32H; export tmp;}

OPD: @(reg_d)+		is metod_d=3 & reg_d {export reg_d;}
OPD: @#imm16"z"		is metod_d=3 & reg_d=7 ; imm16 {tmp:2 = imm16; export tmp;}
OPD: @#imm32H"zz"	is metod_d=3 & reg_d=7 & reg_s=7 ;imm32H {tmp:2 = imm32H; export tmp;}

OPD: -(reg_d)		is metod_d=4 & reg_d {tmp:2 = *:2 reg_d; export tmp;}
OPD: @-(reg_d)		is metod_d=5 & reg_d {tmp:2 = *:2 reg_d; export tmp;}

OPD: imm16(reg_d)	is metod_d=6 & reg_d; imm16 {tmp:2 = imm16; export tmp;}
OPD: imm32H(reg_d)	is metod_d=6 & metod_s=6 &reg_d;imm32H {tmp:2 = imm32H; export tmp;}
OPD: imm32H(reg_d)	is metod_d=6 & metod_s=7 &reg_d;imm32H {tmp:2 = imm32H; export tmp;}

OPD: @imm16(reg_d)	is metod_d=7 & reg_d; imm16 {tmp:2 = imm16; export tmp;}
OPD: @imm32H(reg_d)	is metod_d=7 & metod_s=7 & reg_d;imm32H {tmp:2 = imm32H; export tmp;}
OPD: @imm32H(reg_d)	is metod_d=7 & metod_s=6 & reg_d;imm32H {tmp:2 = imm32H; export tmp;}

# monstru pozymiai visai ne reg_s ir reg_d
# metod_s=7 metod_d=7
# metod_s=6 metod_d=6
# metod_s=6 metod_d=7
# metod_s=7 metod_d=6
# metod_s=2 metod_d=2

RELN: reloc		is rel &nnn	[ reloc = inst_next-nnn*2; ] { export *:2 reloc; } 

######### XOR SOB MUL DIV ASH ASHC
:XOR RRR,OPD	is (kodas_s=7 &metod_s=4 & RRR) ...& OPD {PC=PC;}
:SOB RRR,RELN	is (kodas_s=7 &metod_s=7 & RRR & RELN &nnn)  {goto [RELN];} # SOB RRR,NNN NNN : R := R – 1; IF (R != 0) THEN PC := PC – 2 * NN
:MUL RRR,OPD	is (kodas_s=7 &metod_s=0 & RRR) ...& OPD {OPD=RRR;}
:DIV RRR,OPD	is (kodas_s=7 &metod_s=1 & RRR) ...& OPD {OPD=RRR;}
:ASH RRR,OPD	is (kodas_s=7 &metod_s=2 & RRR) ...& OPD {OPD=RRR;}
:ASHC RRR,OPD	is (kodas_s=7 &metod_s=3 & RRR) ...& OPD {OPD=RRR;}

##################################################################################

:MOV OPS,OPD 	is (kodas_s=1)...& OPD& OPS { OPD = OPS; }
:MOVB OPS,OPD 	is (kodas_s=9)...& OPD& OPS { OPD = OPS; }
:CMP OPS,OPD 	is (kodas_s=2)...& OPD& OPS { OPD = OPS; }
:CMPB OPS,OPD 	is (kodas_s=10)...& OPD& OPS { OPD = OPS; }

:SUB OPS,OPD 	is (kodas_s=0xE)... & OPS & OPD { tmp=OPD-OPS; OPD=tmp;}
:ADD OPS,OPD 	is (kodas_s=0x6)... & OPS & OPD { tmp= OPD+OPS; OPD=tmp;}
:BIT OPS,OPD 	is (kodas_s=0x3)... & OPS & OPD { OPD=OPS; }
:BITB OPS,OPD 	is (kodas_s=0xb)...& OPS & OPD { OPD=OPS; }
:BIC OPS,OPD 	is (kodas_s=0x4)...& OPS & OPD { OPD=OPS; }
:BICB OPS,OPD 	is (kodas_s=12)...& OPS & OPD { OPD=OPS; }
:BIS OPS,OPD 	is (kodas_s=0x5)...& OPS & OPD { OPD=OPS; }
:BISB OPS,OPD 	is (kodas_s=13)...& OPS & OPD  { OPD=OPS; }
:INC OPD		is (kodas_s=0 & metod_s=5 &reg_s=2)... &OPD {PC=PC;}
:INCB OPD		is (kodas_s=8 & metod_s=5 &reg_s=2)... &OPD {PC=PC;}
:CLR OPD		is (kodas_s=0 & metod_s=5 &reg_s=0)... &OPD {PC=PC;}
:CLRB OPD		is (kodas_s=8 & metod_s=5 &reg_s=0)... &OPD {PC=PC;}

:COM OPD		is (kodas_s=0 & metod_s=5 &reg_s=1)... &OPD {PC=PC;}
:COMB OPD		is (kodas_s=8 & metod_s=5 &reg_s=1)... &OPD {PC=PC;}
:DEC OPD		is (kodas_s=0 & metod_s=5 &reg_s=3)... &OPD {PC=PC;}
:DECB OPD		is (kodas_s=8 & metod_s=5 &reg_s=3)... &OPD {PC=PC;}
:NEG OPD		is (kodas_s=0 & metod_s=5 &reg_s=4)... &OPD {PC=PC;}
:NEGB OPD		is (kodas_s=8 & metod_s=5 &reg_s=4)... &OPD {PC=PC;}
:ADC OPD		is (kodas_s=0 & metod_s=5 &reg_s=5)... &OPD {PC=PC;}
:ADCB OPD		is (kodas_s=8 & metod_s=5 &reg_s=5)... &OPD {PC=PC;}

:SBC OPD		is (kodas_s=0 & metod_s=5 &reg_s=6)... &OPD {PC=PC;}
:SBCB OPD		is (kodas_s=8 & metod_s=5 &reg_s=6)... &OPD {PC=PC;}

:ROR OPD		is (kodas_s=0 & metod_s=6 &reg_s=0)... &OPD {OPD=OPD>>1;}
:RORB OPD		is (kodas_s=8 & metod_s=6 &reg_s=0)... &OPD {PC=PC;}
:ROL OPD		is (kodas_s=0 & metod_s=6 &reg_s=1)... &OPD {OPD=OPD<<1;}
:ROLB OPD		is (kodas_s=8 & metod_s=6 &reg_s=1)... &OPD {PC=PC;}
:ASR OPD		is (kodas_s=0 & metod_s=6 &reg_s=2)... &OPD {PC=PC;}
:ASRB OPD		is (kodas_s=8 & metod_s=6 &reg_s=2)... &OPD {PC=PC;}
:ASL OPD		is (kodas_s=0 & metod_s=6 &reg_s=3)... &OPD {PC=PC;}
:ASLB OPD		is (kodas_s=8 & metod_s=6 &reg_s=3)... &OPD {PC=PC;}
:TST OPD		is (kodas_s=0 & metod_s=5 &reg_s=7)... &OPD {PC=PC;}
:TSTB OPD		is (kodas_s=8 & metod_s=5 &reg_s=7)... &OPD {PC=PC;}
:SXT OPD		is (kodas_s=0 & metod_s=6 &reg_s=7)... &OPD {PC=PC;}
:SWAB OPD		is (kodas_s=0 & metod_s=0 &reg_s=3)... &OPD {PC=PC;}
:MFPS OPD		is (kodas_s=8 & metod_s=6 &reg_s=7)... &OPD {PC=PC;}
:MTPS OPD		is (kodas_s=8 & metod_s=6 &reg_s=4)... &OPD {FLG=OPD;}
############################################################################################
RELL: reloc 	is rell  [ reloc = inst_next + rell; ] { export *:2 reloc; } 

# JSR/JMP - need to rewrite
:JMP RELL   is (kodas=1 &metod=6 & regai=7) ; RELL { goto RELL;} #OK
:JMP @RELL	is (kodas=1 &metod=7 & regai=7) ; RELL {goto [RELL];} #JUMP @XXXXX
:JMP OPD	is (kodas=1 & metod<6)... & OPD {PC=OPD; goto [PC];} # JMP R0 ir pan metod:2,3. kiti negalimi

# JSR methods.
JPS: reg_s	is  reg_s {tmp:2 = *:2 reg_s; export tmp;}
I16: imm16	is imm16 {export *:2 imm16;}


:JSR JPS,#I16	is (kodas_s=0 & metod_s=4 & reg_s<7 & reg_d=7 & metod_d=2)& JPS ;I16 {tmp=JPS+I16; call [tmp];}
:JSR JPS,@#I16	is (kodas_s=0 & metod_s=4 & reg_s<7 & reg_d=7 & metod_d=3)& JPS ;I16 {tmp=I16+JPS; call [*:2 tmp];}

:JSR JPS,RELL	is (kodas_s=0 & metod_s=4 & reg_s<7 & reg_d=7 & metod_d=6)& JPS ;RELL {tmp=JPS+RELL; call [*:2 tmp];}
:JSR JPS,@RELL	is (kodas_s=0 & metod_s=4 & reg_s<7 & reg_d=7 & metod_d=7)& JPS ;RELL {tmp=JPS+RELL; call [*:2 tmp];}

:"ILLEGAL CALL 0>"RELL	is (kodas=0x27 & metod_d=0 & reg_d=7) ; RELL { *SP=PC; SP=SP-1; call RELL; }
:"ILLEGAL CALL 1>"RELL	is (kodas=0x27 & metod_d=1 & reg_d=7) ; RELL { *SP=PC; SP=SP-1; call RELL; }
:CALL #I16			is (kodas=0x27 & metod_d=2 & reg_d=7) ; I16 {call [I16];}
:CALL @#I16	is (kodas=0x27 & metod_d=3 & reg_d=7) ; I16 {call I16; }
:"ILLEGAL CALL 4>"RELL	is (kodas=0x27 & metod_d=4 & reg_d=7) ; RELL { *SP=PC; SP=SP-1; call RELL; }
:"ILLEGAL CALL 5>"RELL	is (kodas=0x27 & metod_d=5 & reg_d=7) ; RELL { *SP=PC; SP=SP-1; call RELL; }
:CALL RELL		is (kodas=0x27 & metod_d=6 & reg_d=7) ; RELL { *SP=PC; SP=SP-1; call RELL; }
:CALL "@"RELL	is (kodas=0x27 & metod_d=7 & reg_d=7) ; RELL { *SP=PC; SP=SP-1; call RELL; }

###### RETURN
:RETURN		is imm16=0x87 {PC = *SP; SP = SP+1; return [PC];}
:RTS RRD	is kodas=2 & metod=0 & regai<7 &RRD {PC=RRD; RRD=*SP; SP=SP+1; return [PC];}


:MARK nnn is kodas=0x34 &nnn {PC=PC;} # SP := PC + 2 * NN; PC := R5; R5 := (SP)+
 
# Jumpai (PC registras, R7)
#          543210
# 2 - #X   010 111 = 17
# 3 - @#X  011 111 = 1f
# 6 - X    110 111 = 37
# 7 - @X   111 111 = 3f

######## FPU FPU FPU #########################

FRD: reg_d is reg_d			{ export *:1 reg_d; }
:FADD FRD	is fpu=0b0111101000000 & FRD {PC=PC;}
:FSUB FRD	is fpu=0b0111101000001 & FRD {PC=PC;}
:FMUL FRD	is fpu=0b0111101000010 & FRD {PC=PC;}
:FDIV FRD	is fpu=0b0111101000011 & FRD {PC=PC;}

######## HALT MODE ############################

#:START ($RUN$) = o10-o13
#:STEP ($STEP$) =o14-o17
#:RSEL ($MFSL$) =o20
#:MFUS ($MFPM$) = o21
#:RCPC ($MFPC$) = o22-o23
#:RCPS ($MFPS$) = o24-o27
#:MTUS ($MTPM$) = o31
#:WCPC ($MTPC$) = o32-o33
#:WCPS ($MTPS$) = o34-o37
#:???? = o30


# programinis dugnas. (c)2026 http://www.vabolis.lt