### DEC PDP11 (J11) CPU minimal implementation. ###############
# sorry, I do not understand SLEIGH.                          #
# (c)2026, www.vabolis.lt                                     #
#                                        Levas                #
# Freeware & etc. Please leave copyright note                 #
###############################################################


# WARNING! ALL STUFF in {} is untested.

define endian=little;
define alignment=2;

define space ram      type=ram_space      size=2 default; # would like to have 3, but errors...
define space register type=register_space size=2;

# R0–R7 (SP=R6, PC=R7)
define register offset=0x0000 size=2 [ R0 ];
define register offset=0x0002 size=2 [ R1 ];
define register offset=0x0004 size=2 [ R2 ];
define register offset=0x0006 size=2 [ R3 ];
define register offset=0x0008 size=2 [ R4 ];
define register offset=0x000A size=2 [ R5 ];
define register offset=0x000C size=2 [ SP ]; #R6 , stekas mazejantis


define register offset=0x000E size=2 [ PC ]; #R7
define register offset=0x0020 size=2 [ PS ]; # ony one byte. Keep 2 to make SLEIGHT happy

# Flag Register Contents (PS)
#
# b15         - Reserved area
# b14:b12     - Processor interrupt priority level
# b11:b8     - Reserved area
# b7        - (U) Stack pointer select flag
# b6         - (I) Interrupt enable flag
# b5         - (O) Overflow flag
# b4        - (B) Register bank select flag
# b3         - (S) Sign flag
# b2        - (Z) Zero flag
# b1        - (D) Debug flag
# b0        - (C) Carry flag

@define FC         "PS[0,1]" #cary
@define DEBUG         "PS[1,1]"
@define FZ          "PS[2,1]" #zero
@define FS          "PS[3,1]" #sign
@define REG_BANK      "PS[4,1]"
@define FV    "PS[5,1]" #oVerflow
@define INTERRUPT   "PS[6,1]"
@define STACK_SEL   "PS[7,1]"
@define IPL         "PS[12,3]"

macro CC(){PS[0,1]=0;}
macro SC(){PS[0,1]=1;}
macro CZ(){PS[2,1]=0;}
macro SZ(){PS[2,1]=1;}
macro CS(){PS[3,1]=0;}
macro SS(){PS[3,1]=1;}
macro CN(){PS[3,1]=0;}
macro SN(){PS[3,1]=1;}
macro CV(){PS[5,1]=0;}
macro SV(){PS[5,1]=1;}
macro CI(){PS[6,1]=0;}
macro SI(){PS[6,1]=1;}

macro flag(register_s, register_d) {
PS[2,1]=( register_s == register_d ); #zero
PS[3,1]=( register_s > register_d ); # N, sign
#SIGN= 	sext(register_d);
PS[5,1]=carry(register_s, register_d) || sborrow(register_d, register_s); #V, overflow
PS[0,1]=(register_s[15,1]==1) && (register_d[15,1]==1); #carry

}

macro FLG(register)
{
PS[2,1]=( register==0); #zero
PS[0,1]=( register==0); #carry

}
macro MemRead(dest,adresas) {
   	ptr:2 = adresas;
	dest = *:2 ptr;
}

macro MemStore(adresas,val) {
   	ptr:2 = adresas;
	*:2 ptr = val;
}

#
# FLAG MACROS...
#

macro push(val) {
    SP = SP - 2;
    ptr:2 = (SP);
    *:2 ptr = val;
}
macro pop(val) {
    ptr:2 = (SP);
    val = *:2 ptr;
    SP = SP + 2;
}

#TOKENS

# main opcode
define token word_1 (16)
	byte = (15,15)
	kodas = (6,15)
	metod = (3,5)
	regai =(0,2)
	
	op_h =(8,15)
	rell = (0,7) signed
	baitas = (0,7)
	
	kodas_s = (12,15)
	met_s=(9,11)
	reg_s=(6,8)
	reg_ss=(6,8)
	met_d=(3,5)
	reg_d=(0,2)
	reg_dd=(0,2)
	nnn=(0,5)
	fpu=(3,15)
;

attach variables [ reg_s] [ R0 R1 R2 R3 R4 R5 SP PC];
attach variables [ reg_d] [ R0 R1 R2 R3 R4 R5 SP PC];

# one byte, not used here
#define token data8 (8)
#   imm8		= (0,7)
#   rela		= (0,7) signed
#;

# next word with data or first opcode
define token data_word (16)
	imm16 = (0,15)
	rell16	=(0,15) signed
;

# THIS HACK. I do not know how to use two imm16, two words of data (4 bytes)
define token data_double_word (32)
	imm32=(0,31)
	imm32H=(16,31)
	rell32h=(16,31) signed
	imm32L=(0,15)
	rell32l=(0,15) signed
;
# Relative addressing. Note x2 multiplication (adressing is in words)
REL8:	reloc	is rell			[reloc = inst_next + 2 * rell;]	{ export *:2 reloc; } 
# relative values from extra bytes.
REL32H:	reloc 	is rell32h  	[reloc = inst_next + rell32h;]	{ export *:2 reloc; } 
REL32L:	reloc 	is rell32l  	[reloc = inst_next + rell32l-2;]	{ export *:2 reloc; } 
REL16:	reloc	is rell16   	[reloc = inst_next + rell16;]	{tmp:2 = 0; tmp=reloc; export  tmp; }
RELN:	reloc	is rell &nnn	[reloc = inst_next-nnn*2;]		{ export *:2 reloc; } 
# NE16:   ne16 	is reg_s [ne16= inst_next;] {export *:2 ne16;}
# offset = offset + inst_next_addr;

# ############# VEIKIANTYS 
:NOP		is imm16=0x0A0	{R0=R0;}
:HALT		is imm16=0		{ PC=(0x28); goto [PC];}
:WAIT		is imm16=1		{ PC=PC-2; goto [PC];}
:CLC		is imm16=0x0A1 {PS[0,1]=0;}
:CLV		is imm16=0x0A2 {PS[5,1]=0;}
:CLZ		is imm16=0x0A4 {PS[2,1]=0;}
:CLN		is imm16=0x0A8 {PS[3,1]=0;}
:CCC		is imm16=0x0AF {PS[0,1]=0; PS[5,1]=0; PS[2,1]=0; PS[3,1]=0; }

:SEC		is imm16=0x0b1 {PS[0,1]=1;}
:SEV		is imm16=0x0b2 {PS[5,1]=1;}
:SEZ		is imm16=0x0b4 {PS[2,1]=1;}
:SEN		is imm16=0x0b8 {PS[3,1]=1;}
:SCC		is imm16=0x0bF {PS[0,1]=1; PS[5,1]=1; PS[2,1]=1; PS[3,1]=1; }
:EMT "'"baitas"'"		is op_h=0x88 & baitas { push(PS); push(PC); PC=(0x18); call [PC];} # NETEISYBE
:TRAP		is op_h=0x89 {push(PS); push(PC); PC=(0x1C); call [PC];} # NETEISYBE
:IOT		is imm16=0x004 {push(PS); push(PC); PC=(0x10); PS=(0x12); call [PC];} # NETEISYBE
:BPT		is imm16=0x003 {push(PS); push(PC); PC=(0x0C); PS=(0x0E); call [PC];} # NETEISYBE
:RTI		is imm16=0x002 {pop(PC); pop(PS); return [PC];} # NETEISYBE
:RTT		is imm16=0x006 {pop(PC); pop(PS); return [PC];} # NETEISYBE
:RESET		is imm16=0x005 {SP=SP;}

:BR   REL8			is op_h=1 & REL8 {goto REL8;}
:BNE  REL8			is op_h=2 & REL8 {if !PS[2,1] goto REL8;} # Z=0
:BEQ  REL8			is op_h=3 & REL8 {if PS[2,1] goto REL8;} # Z=1
:BPL  REL8			is op_h=0x80 & REL8 {if !PS[3,1] goto REL8;} # N=0 sign
:BMI  REL8			is op_h=0x81 & REL8 {if PS[3,1] goto REL8;} # N=1
:BVC  REL8			is op_h=0x84 & REL8 {if !PS[5,1] goto REL8;} # V=0 overflow
:BVS  REL8			is op_h=0x85 & REL8 {if PS[5,1] goto REL8;} # V=1
:BCC  REL8			is op_h=0x86 & REL8 {if !PS[0,1] goto REL8;} # C=0 carry
:BCS  REL8			is op_h=0x87 & REL8 {if PS[0,1] goto REL8;} # C=1
:BGE  REL8			is op_h=4 & REL8 {if !(PS[3,1] ^ PS[5,1]) goto REL8;} # N xor V =0
:BLT  REL8			is op_h=5 & REL8 {if (PS[3,1] ^ PS[5,1]) goto REL8;} # N xor V =1
:BGT  REL8			is op_h=6 & REL8 {if( !(PS[3,1] ^ PS[5,1])|!PS[2,1])goto REL8;} # (N xor V) or Z =0
:BLE  REL8			is op_h=7 & REL8 {if( (PS[3,1] ^ PS[5,1])|PS[2,1])goto REL8;} # (N xor V) or Z =0
:BHI  REL8			is op_h=0x82 & REL8 {if(!PS[0,1] | !PS[2,1])goto REL8;} # C or Z =0
:BLOS REL8			is op_h=0x83 & REL8 {if(PS[0,1] | PS[2,1])goto REL8;} # C or Z =1

# is manualo
# file:///C:/Users/User/Downloads/ghidra_12.0_PUBLIC_20251205/ghidra_12.0_PUBLIC/docs/languages/html/sleigh_constructors.html#sleigh_sections_constructor

####################### VARIANTAI adresacijos #############################################
#export only register names
RRR: reg_s is reg_s { export *:2 reg_s;}
RRD: reg_d is reg_d { export *:2 reg_d;}


# adresacijos metodai (mode)? arba
# 0 - registras Rn ; =R
# 1 - netiesioginis registras @Rn arba (Rn) - viduje registro reiksme; =peek(R)
# 2 - autoinkrementinis (Rn)+ ; =peek(R), R=R+1
# 3 - @(Rn)+
# 4 - -(Rn)
# 5 - @-(Rn)
# 6 - indeksinis X(Rn)
# 7 - @X(Rn)

# SOURCE

# MODE0: Operand is in the register
# operand = Rn
OPS: reg_s" OK0"			is met_s=0 & reg_s {tmp:2 =  reg_s; export tmp;}

# MODE1:(register deferred)
# Register contains the address of the operand
# EA = Rn
# operand = MEM[EA]
OPS: "("reg_s") OK1"		is met_s=1 & reg_s {tmp:2 =0;  MemRead(tmp,reg_s); export tmp;}

# MODE2: (autoincrement)
# EA = Rn
# operand = MEM[EA]
# Rn = Rn + (is_byte ? 1 : 2)
OPS: "("reg_s")+ OK2a"		is byte=1 & met_s=2 & reg_s {tmp:2 = 0; MemRead(tmp,reg_s); reg_s=reg_s+1; export tmp;}
OPS: "("reg_s")+ OK2b"		is byte=0 & met_s=2 & reg_s {tmp:2 = 0; MemRead(tmp,reg_s); reg_s=reg_s+2; export tmp;}
OPS: "#"imm16" OK2c"		is byte=0 & met_s=2 & reg_s=7 & reg_s ;imm16{tmp:2 = imm16; reg_s=reg_s+2; export tmp;}
OPS: "#"imm16" OK2c"		is byte=1 & met_s=2 & reg_s=7 & reg_s ;imm16{tmp:2 = imm16; reg_s=reg_s+2; export tmp;}

# MODE3: (autoincrement deferred)
# EA_ptr = Rn
# EA = MEM[EA_ptr]
# operand = MEM[EA]
# Rn = Rn + 2

OPS: "@("reg_s")+ OK3a"		is met_s=3& reg_ss!=7 & (met_d=0 | met_d=1 | met_d=4 | met_d=5)   & reg_s 				{tmp:2 = *:2 reg_s; tmp2=*:2 tmp; reg_s=reg_s+2; export tmp2;}
OPS: "@("reg_s")+ OK3b"		is met_s=3& reg_ss!=7 & (met_d=2 | met_d=3) &                 reg_d!=7        & reg_s	{tmp:2 = *:2 reg_s; tmp2=*:2 tmp; reg_s=reg_s+2; export tmp2;}
OPS: "@("reg_s")+ OK3c"		is met_s=3& reg_ss!=7 & (met_d=2 | met_d=3) &                 reg_d=7         & reg_s	{tmp:2 = *:2 reg_s; tmp2=*:2 tmp; reg_s=reg_s+2; export tmp2;}
OPS: "@("reg_s")+ OK3d"		is met_s=3& reg_ss!=7 & (met_d=6 | met_d=7) &                        reg_s 				{tmp:2 = *:2 reg_s; tmp2=*:2 tmp; reg_s=reg_s+2; export tmp2;}
OPS: "@#"imm16" OK3e"		is met_s=3&  reg_ss=7 & (met_d=0 | met_d=1 | met_d=4 | met_d=5)    & reg_s ;imm16 		{tmp:2 =imm16; export tmp;}
OPS: "@("reg_s")+ OK3f"		is met_s=3&  reg_ss=7 & (met_d=2 | met_d=3) &                 reg_d!=7         & reg_s 	{tmp:2 = *:2 reg_s; tmp2=*:2 tmp; reg_s=reg_s+2; export tmp2;}
OPS: "@#"imm32L" OK3g"		is met_s=3&  reg_ss=7 & (met_d=2 | met_d=3) &                 reg_d=7  & reg_s;imm32L	{tmp:2 = imm32L; export tmp;}
OPS: "@#"imm32L" OK3h"		is met_s=3&  reg_ss=7 & (met_d=6 | met_d=7) &                  reg_s ;imm32L			{tmp:2 = imm32L; export tmp;}

# MODE4: (autodecrement)
# Rn = Rn - (is_byte ? 1 : 2)
# EA = Rn
# operand = MEM[EA]
OPS: "-("reg_s") OK4"		is met_s=4 & reg_s {reg_s=reg_s-2; tmp:2 = *:2 reg_s; export tmp;}

# MODE5: (autodecrement deferred)
# Rn = Rn - 2
# EA_ptr = Rn
# EA = MEM[EA_ptr]
# operand = MEM[EA]
OPS: "@-("reg_s") OK5a"		is met_s=5 & reg_s {reg_s=reg_s-2; tmp:2 = *:2 reg_s; tmp2=*:2 tmp; export tmp2;}

# MODE6: (index)
# EA = Rn + offset
# operand = MEM[EA]
OPS: imm16"("reg_s") OK6a"	is met_s=6 & reg_s		;imm16			{tmp:2 = imm16+reg_s; export *:2 tmp;}
OPS: REL16"] OK6b"			is met_s=6 & reg_s=7 	;REL16			{export REL16;}
OPS: REL32L" OK6c"			is met_s=6 & met_d=6 & reg_s=7 ;REL32L	{tmp:2 = REL32L; export *:2 tmp;}
OPS: REL32L" OK6d"			is met_s=6 & met_d=7 & reg_s=7 ;REL32L	{tmp:2 = REL32L; export *:2 tmp;}
OPS: imm32L"("reg_s") OK6e"	is met_s=6 & met_d=6 & reg_s ;imm32L	{tmp:2 = imm32L+reg_s; export *:2 tmp;}
OPS: imm32L"("reg_s")?OK6f"	is met_s=6 & met_d=7 & reg_s ;imm32L	{tmp:2 = imm32L+reg_s; export *:2 tmp;}
OPS: REL32L" OK6g"			is met_s=6 & met_d=3 & reg_s=7;REL32L	{tmp:2 = REL32L; export *:2 tmp;}
OPS: imm32L" OK6h"			is met_s=6 & met_d=3 & reg_d=7 & reg_s!=7;imm32L	{tmp:2 = imm32L; export *:2 tmp;}

# MODE7: (index deferred)
# EA_ptr = Rn + offset
# EA = MEM[EA_ptr]
# operand = MEM[EA]
OPS: "@"imm16"("reg_s")7a" is met_s=7 & (met_d=0 | met_d=1 | met_d=4 | met_d=5) & reg_ss!=7 & reg_s ;imm16	{tmp:2 = imm16+reg_s; export *:2 tmp;}
OPS: "@"REL16" 7f" 			is met_s=7 & (met_d=0 | met_d=1 | met_d=4 | met_d=5) & reg_ss=7 & reg_s ;REL16	{tmp:2 = REL16; export *:2 tmp;}
OPS: "@"REL16"("reg_s")7b"	is met_s=7 & (met_d=2 | met_d=3) &reg_d!=7 & reg_s 			;REL16				{tmp:2 = REL16+reg_s; export *:2 tmp;}
OPS: "@"REL32L"?OK7c"		is met_s=7 & reg_s=7 & (met_d=2 | met_d=3) &reg_d=7				;REL32L			{tmp:2 = REL32L; export *:2 tmp;}
OPS: "@"imm32L"("reg_s") OK7cc"	is met_s=7 & reg_ss!=7 & (met_d=2 | met_d=3) &reg_d=7 &reg_s;imm32L			{tmp:2 = imm32L+reg_s; export *:2 tmp;}
OPS: "@"imm32L"?OK7d"		is met_s=7 &         (met_d=6 | met_d=7) & reg_ss!=7	&reg_s	;imm32L			{tmp:2 = imm32L+reg_s; export *:2 tmp;}
OPS: "@"REL32L"?OK7e"		is met_s=7 &         (met_d=6 | met_d=7) & reg_s=7				;REL32L			{tmp:2 = REL32L; export *:2 tmp;}


# DESTINATION
OPD: reg_d" OK0"	is met_d=0 & reg_d 			{export reg_d;}
OPD: "("reg_d") OK1"	is met_d=1 & reg_d 		{export *:2 reg_d;}


#OPD: "("reg_d")+ OK2"	is met_d=2 & reg_d 		{reg_d=reg_d+2; export *:2 reg_d;}
#OPD: "<2#>"imm16	is met_d=2 & reg_d=7 ;imm16	{tmp:2 = imm16; export *:2 tmp;}
OPD: "("reg_d")+ OK2a"		is byte=1 & met_d=2 & reg_d {tmp:2 = 0; MemRead(tmp,reg_d); reg_d=reg_d+1; export tmp;}
OPD: "("reg_d")+ OK2b"		is byte=0 & met_d=2 & reg_d {tmp:2 = 0; MemRead(tmp,reg_d); reg_d=reg_d+2; export tmp;}
OPD: "#"imm16" OK2c"		is byte=0 & met_d=2 & reg_d=7 & reg_d ;imm16{tmp:2 = imm16; reg_d=reg_d+2; export tmp;}
OPD: "#"imm16" OK2c"		is byte=1 & met_d=2 & reg_d=7 & reg_d ;imm16{tmp:2 = imm16; reg_d=reg_d+2; export tmp;}





# MODE3: (autoincrement deferred)
# EA_ptr = Rn
# EA = MEM[EA_ptr]
# operand = MEM[EA]
# Rn = Rn + 2
OPD: "@("reg_d")+ OK3a"		is met_d=3& reg_dd!=7 & (met_s=0 | met_s=1 | met_s=4 | met_s=5) & reg_d 		{tmp:2 = *:2 reg_d; reg_d=reg_d+2; export tmp;}
OPD: "@("reg_d")+ OK3b"		is met_d=3& reg_dd!=7 & (met_s=2 | met_s=3) &    reg_s!=7 & reg_d 				{tmp:2 = *:2 reg_d; reg_d=reg_d+2; export tmp;}
OPD: "@("reg_d")+ OK3c"		is met_d=3& reg_dd!=7 & (met_s=2 | met_s=3) &  reg_s=7 & reg_d 					{tmp:2 = *:2 reg_d; reg_d=reg_d+2; export tmp;}
OPD: "@("reg_d")+ OK3d"		is met_d=3& reg_dd!=7 & (met_s=6 | met_s=7) &  reg_d 							{tmp:2 = *:2 reg_d; reg_d=reg_d+2; export tmp;}
OPD: "@#"imm16" OK3e"		is met_d=3&  reg_dd=7 & (met_s=0 | met_s=1 | met_s=4 | met_s=5) & reg_d ;imm16 	{tmp:2 =imm16; export *:2 tmp;}
OPD: "@("reg_d")+ OK3f"		is met_d=3&  reg_dd=7 & (met_s=2 | met_s=3) &   reg_s!=7 & reg_d 				{tmp:2 = *:2 reg_d; reg_d=reg_d+2; export tmp;}
OPD: "@#"imm32H" OK3g"		is met_d=3&  reg_dd=7 & (met_s=2 | met_s=3) &   reg_s=7  & reg_d;imm32H 		{tmp:2 = imm32H; export *:2 tmp;}
OPD: "@#"imm32H" OK3h"		is met_d=3&  reg_dd=7 & (met_s=6 | met_s=7) & reg_d=7  ; imm32H 				{tmp:2 = imm32H; export *:2 tmp;}

# MODE4: (autodecrement)
# Rn = Rn - (is_byte ? 1 : 2)
# EA = Rn
# operand = MEM[EA]
OPD: "-("reg_d") OK4a"	is met_d=4 & reg_d 	{reg_d=reg_d-2; tmp:2 = *:2 reg_d; export tmp;}

# MODE5: (autodecrement deferred)
# Rn = Rn - 2
# EA_ptr = Rn
# EA = MEM[EA_ptr]
# operand = MEM[EA]
OPD: "@-("reg_d") OK5a"	is met_d=5 & reg_d 	{reg_d=reg_d-2; tmp:2 = *:2 reg_d; export tmp;}

# MODE6: (index)
# EA = Rn + offset
# operand = MEM[EA]
OPD: imm16"("reg_d") OK6a"	is met_d=6 & reg_d;imm16							{tmp:2 = imm16+reg_d; export *:2 tmp;}
OPD: REL16" OK6b"			is met_d=6 & reg_d=7 ;REL16							{tmp:2 = REL16; export *:2 tmp;}
OPD: REL32H" OK6c"			is met_d=6 & met_s=6 & reg_d=7 ;REL32H				{tmp:2 = REL32H; export *:2 tmp;}
OPD: REL32H" OK6d"			is met_d=6 & met_s=7 & reg_d=7 ;REL32H				{tmp:2 = REL32H; export *:2 tmp;}
OPD: imm32H"("reg_d") OK6e"	is met_d=6 & met_s=6 & reg_d ;imm32H				{tmp:2 = imm32H+reg_d; export *:2 tmp;}
OPD: imm32H"("reg_d")?OK6f"	is met_d=6 & met_s=7 & reg_d ;imm32H				{tmp:2 = imm32H+reg_d; export *:2 tmp;}
OPD: REL32H" OK6g"			is met_d=6 & met_s=3 & reg_d=7;REL32H				{tmp:2 = REL32H; export *:2 tmp;}
OPD: imm32H" OK6h"			is met_d=6 & met_s=3 & reg_s=7 & reg_d!=7;imm32H	{tmp:2 = imm32H; export *:2 tmp;}

# MODE7: (index deferred)
# EA_ptr = Rn + offset
# EA = MEM[EA_ptr]
# operand = MEM[EA]
OPD: "@"imm16"("reg_d")7a" is met_d=7 & (met_s=0 | met_s=1 | met_s=4 | met_s=5) & reg_dd!=7 & reg_d ;imm16	{tmp:2 = imm16+reg_d; tmp2=*:2 tmp; export *:2 tmp2;}
OPD: "@"REL16" ok7f" is met_d=7 & (met_s=0 | met_s=1 | met_s=4 | met_s=5) & reg_dd=7 & reg_d ;REL16			{tmp:2 = REL16; export *:2 tmp;}
OPD: "@"REL16"("reg_d")7b" is met_d=7 & (met_s=2 | met_s=3) &reg_s!=7 & reg_d 			;REL16				{tmp:2 = REL16; export *:2 tmp;}
OPD: "@"REL32H"?OK7c"	is met_d=7 & reg_d & (met_s=2 | met_s=3) &reg_s=7				;REL32H				{tmp:2 = REL32H; export *:2 tmp;}
OPD: "@"imm32H"("reg_d") OK7cc"	is met_d=7 & reg_dd!=7 & (met_s=2 | met_s=3) &reg_s=7 & reg_d	;imm32H		{tmp:2 = imm32H+reg_d; tmp2=*:2 tmp; export *:2 tmp2;}
OPD: "@"imm32H"?OK7d"	is met_d=7 &         (met_s=6 | met_s=7) & reg_d!=7				;imm32H				{tmp:2 = imm32H; export *:2 tmp;}
OPD: "@"REL32H"?OK7e"	is met_d=7 &         (met_s=6 | met_s=7) & reg_d=7				;REL32H				{tmp:2 = REL32H; export *:2 tmp;}

######### XOR SOB MUL DIV ASH ASHC
:XOR RRR,OPD	is (kodas_s=7 &met_s=4 & RRR) ...& OPD {OPD=OPD^RRR;}
:SOB RRR,RELN	is (kodas_s=7 &met_s=7 & RRR & RELN &nnn)
	{RRR=RRR-1;
	if (RRR==0) goto inst_next;
	goto [RELN];
	} # SOB RRR,NNN NNN : R := R – 1; IF (R != 0) THEN PC := PC – 2 * NN

:MUL RRR,OPD	is (kodas_s=7 &met_s=0 & RRR) ...& OPD {OPD=OPD*RRR;}
:DIV RRR,OPD	is (kodas_s=7 &met_s=1 & RRR) ...& OPD {OPD=OPD/RRR;}
:ASH RRR,OPD	is (kodas_s=7 &met_s=2 & RRR) ...& OPD {OPD=RRR;}
:ASHC RRR,OPD	is (kodas_s=7 &met_s=3 & RRR) ...& OPD {OPD=RRR;}

##################################################################################

:MOV OPS,OPD 	is (kodas_s=0x1)...& OPD & OPS { OPD = OPS; flag(OPS,OPD);}
:MOVB OPS,OPD 	is (kodas_s=0x9)...& OPD & OPS { OPD=OPD & 0xFF00; OPD =OPD | (OPS & 0x00FF); FLG(OPD);}
:CMP OPS,OPD 	is (kodas_s=0x2)...& OPD & OPS { flag(OPS,OPD); }
:CMPB OPS,OPD 	is (kodas_s=0xA)...& OPD & OPS { flag(OPS,OPD); }

:SUB OPS,OPD 	is (kodas_s=0xE)... & OPS & OPD { OPD=OPD-OPS;}
:ADD OPS,OPD 	is (kodas_s=0x6)... & OPS & OPD { OPD=OPD+OPS;}
:BIT OPS,OPD 	is (kodas_s=0x3)... & OPS & OPD { OPD=OPD; }
:BITB OPS,OPD 	is (kodas_s=0xB)... & OPS & OPD { OPD=OPD; }
:BIC OPS,OPD 	is (kodas_s=0x4)... & OPS & OPD { OPD=(~OPS) & OPD; } #bit clear dst=not(src) and (dst)
:BICB OPS,OPD 	is (kodas_s=0xC)... & OPS & OPD { OPD=OPS; }
:BIS OPS,OPD 	is (kodas_s=0x5)... & OPS & OPD { OPD=OPD | OPS; }
:BISB OPS,OPD 	is (kodas_s=0xD)... & OPS & OPD { OPD=OPS; }
:INC OPD		is (kodas_s=0 & met_s=5 &reg_s=2)... &OPD {OPD=OPD+1; FLG(OPD);}
:INCB OPD		is (kodas_s=8 & met_s=5 &reg_s=2)... &OPD {OPD=OPD+1; FLG(OPD);}
:CLR OPD		is (kodas_s=0 & met_s=5 &reg_s=0)... &OPD {OPD=0; CN(); SZ(); CV(); CC();}
:CLRB OPD		is (kodas_s=8 & met_s=5 &reg_s=0)... &OPD {OPD=0; CN(); SZ(); CV(); CC();}

:COM OPD		is (kodas_s=0 & met_s=5 &reg_s=1)... &OPD {OPD=~OPD; FLG(OPD);}
:COMB OPD		is (kodas_s=8 & met_s=5 &reg_s=1)... &OPD {PC=PC;}
:DEC OPD		is (kodas_s=0 & met_s=5 &reg_s=3)... &OPD {OPD=OPD-1; FLG(OPD);}
:DECB OPD		is (kodas_s=8 & met_s=5 &reg_s=3)... &OPD {PC=PC;}
:NEG OPD		is (kodas_s=0 & met_s=5 &reg_s=4)... &OPD {OPD=-OPD; FLG(OPD);}
:NEGB OPD		is (kodas_s=8 & met_s=5 &reg_s=4)... &OPD {PC=PC;}
:ADC OPD		is (kodas_s=0 & met_s=5 &reg_s=5)... &OPD {if !(PS[0,1]) goto <b>;OPD=OPD+1;<b>}
:ADCB OPD		is (kodas_s=8 & met_s=5 &reg_s=5)... &OPD {OPD=OPD;}

:SBC OPD		is (kodas_s=0 & met_s=5 &reg_s=6)... &OPD {if !(PS[0,1]) goto <b>;OPD=OPD-1;<b>}
:SBCB OPD		is (kodas_s=8 & met_s=5 &reg_s=6)... &OPD {PC=PC;}

:ROR OPD		is (kodas_s=0 & met_s=6 &reg_s=0)... &OPD {OPD=OPD>>1;}
:RORB OPD		is (kodas_s=8 & met_s=6 &reg_s=0)... &OPD {OPD=OPD;}
:ROL OPD		is (kodas_s=0 & met_s=6 &reg_s=1)... &OPD {OPD=OPD<<1;}
:ROLB OPD		is (kodas_s=8 & met_s=6 &reg_s=1)... &OPD {OPD=OPD;}
:ASR OPD		is (kodas_s=0 & met_s=6 &reg_s=2)... &OPD {OPD=OPD;}
:ASRB OPD		is (kodas_s=8 & met_s=6 &reg_s=2)... &OPD {OPD=OPD;}
:ASL OPD		is (kodas_s=0 & met_s=6 &reg_s=3)... &OPD {OPD=OPD;}
:ASLB OPD		is (kodas_s=8 & met_s=6 &reg_s=3)... &OPD {OPD=OPD;}
:TST OPD		is (kodas_s=0 & met_s=5 &reg_s=7)... &OPD {FLG(OPD);}
:TSTB OPD		is (kodas_s=8 & met_s=5 &reg_s=7)... &OPD {FLG(OPD & 0x00FF);}
:SXT OPD		is (kodas_s=0 & met_s=6 &reg_s=7)... &OPD {tmp=0xFFFF;if (PS[3,1]) goto <b>;tmp=0;<b>OPD=tmp;}
:SWAB OPD		is (kodas_s=0 & met_s=0 &reg_s=3)... &OPD {tmp=OPD>>8; OPD=OPD<<8+tmp;}
:MFPS OPD		is (kodas_s=8 & met_s=6 &reg_s=7)... &OPD {OPD=PS;}
:MTPS OPD		is (kodas_s=8 & met_s=6 &reg_s=4)... &OPD {PS=OPD;}
############################################################################################

# Jumpai (PC registras, R7)
#          543210
# 2 - #X   010 111 = 17
# 3 - @#X  011 111 = 1f
# 6 - X    110 111 = 37
# 7 - @X   111 111 = 3f

# JSR/JMP - need to rewrite
:JMP REL16   	is (kodas=1 &metod=6 & regai=7) ; REL16 { goto REL16;} #OK
:JMPX "?"OPD		is (kodas=1 &metod=6 & regai!=7)... &OPD  {tmp= OPD; goto [tmp];}
# {tmp=*:2 OPD; goto [tmp];}

:JMP @REL16		is (kodas=1 &metod=7 & regai=7) ; REL16 {goto [REL16];} #JUMP @XXXXX
:JMP OPD		is (kodas=1 & metod<6)... & OPD {tmp= OPD; goto [tmp];} # JMP R0 ir pan metod:2,3. kiti negalimi

# JSR methods.
JPS: reg_s	is  reg_s {tmp:2 = *:2 reg_s; export tmp;}
I16: imm16	is imm16 {export *:2 imm16;}
# v0=v1; assign v1 to v0.
# *v0=v1; v0 is pointer to space. Store v1 to space
# *[space]v0=v1;
# *:4 v0 = v1;
# *[space]:4 v0=v1;
#
# galimi tik sitie
# goto v0; goto to address of v0
# goto [v0]; goto to as offset of current space
# call v0;
# call [v0];
# return [v0];

:JSRa JPS,(RRD)	is (kodas_s=0 & met_s=4 & reg_s<7 & met_d=1)& RRD &JPS{tmp=JPS+RRD; call [tmp];}
:JSRb JPS,#I16	is (kodas_s=0 & met_s=4 & reg_s<7 & reg_d=7 & met_d=1)& JPS ;I16 {tmp=JPS+I16; call [tmp];}
:JSRc JPS,#I16	is (kodas_s=0 & met_s=4 & reg_s<7 & reg_d=7 & met_d=2)& JPS ;I16 {tmp=JPS+I16; call [tmp];}
:JSRd JPS,@#I16	is (kodas_s=0 & met_s=4 & reg_s<7 & reg_d=7 & met_d=3)& JPS ;I16 {tmp=I16+JPS; call [*:2 tmp];}
:JSRe JPS,REL16	is (kodas_s=0 & met_s=4 & reg_s<7 & reg_d=7 & met_d=6)& JPS ;REL16 {tmp=JPS+REL16; call [*:2 tmp];}
:JSRf JPS,@REL16	is (kodas_s=0 & met_s=4 & reg_s<7 & reg_d=7 & met_d=7)& JPS ;REL16 {tmp=JPS+REL16; call [*:2 tmp];}
:JSRg "PC?",OPD	is (kodas=0x27 & reg_d!=7)... & OPD {call OPD;}

:"ILLEGAL CALL 0>"REL16	is (kodas=0x27 & met_d=0 & reg_d=7) ; REL16 { *SP=PC; SP=SP-1; call REL16; }
:"ILLEGAL CALL 1>"REL16	is (kodas=0x27 & met_d=1 & reg_d=7) ; REL16 { *SP=PC; SP=SP-1; call REL16; }
:CALL #I16				is (kodas=0x27 & met_d=2 & reg_d=7) ; I16 {call [I16];}
:CALL @#I16				is (kodas=0x27 & met_d=3 & reg_d=7) ; I16 {call I16; }
:"ILLEGAL CALL 4>"REL16	is (kodas=0x27 & met_d=4 & reg_d=7) ; REL16 { *SP=PC; SP=SP-1; call REL16; }
:"ILLEGAL CALL 5>"REL16	is (kodas=0x27 & met_d=5 & reg_d=7) ; REL16 { *SP=PC; SP=SP-1; call REL16; }
:CALL REL16				is (kodas=0x27 & met_d=6 & reg_d=7) ; REL16 { *SP=PC; SP=SP-1; call REL16; }
:CALL "@"REL16			is (kodas=0x27 & met_d=7 & reg_d=7) ; REL16 { *SP=PC; SP=SP-1; call REL16; }

###### RETURN
:RETURN		is imm16=0x87 {pop(PC); pop(PS); return [PC];}
:RTS RRD	is kodas=2 & metod=0 & regai<7 &RRD {pop(PC); pop(RRD); return [PC];}


:MARK nnn is kodas=0x34 &nnn {SP=PC+2*nnn;PC=R5;pop(R5);} # SP := PC + 2 * NN; PC := R5; R5 := (SP)+
 


######## FPU FPU FPU #########################

FRD: reg_d is reg_d			{ export *:1 reg_d; }
:FADD FRD	is fpu=0b0111101000000 & FRD {PC=PC;}
:FSUB FRD	is fpu=0b0111101000001 & FRD {PC=PC;}
:FMUL FRD	is fpu=0b0111101000010 & FRD {PC=PC;}
:FDIV FRD	is fpu=0b0111101000011 & FRD {PC=PC;}

######## HALT MODE ############################

#:START ($RUN$) = o10-o13
#:STEP ($STEP$) =o14-o17
#:RSEL ($MFSL$) =o20
#:MFUS ($MFPM$) = o21
#:RCPC ($MFPC$) = o22-o23
#:RCPS ($MFPS$) = o24-o27
#:MTUS ($MTPM$) = o31
#:WCPC ($MTPC$) = o32-o33
#:WCPS ($MTPS$) = o34-o37
#:???? = o30


# programinis dugnas. (c)2026 http://www.vabolis.lt